#第二章 课题1.线程

在这一任务中，我们会向你提供一个最简单的、可以工作的线程系统。你的任务就是将其功能扩展，并在此过程中获得更多有关同步问题的知识。


你在这一任务中所要做的大部分工作都是在**threads**工作夹下完成的，另外还有一些工作需要你在**devices**目录下完成。需要强调的是编译需要在**threads**工作夹下完成。


在你阅读本任务的简述之前，以下的章节是你需要阅读的：位于第1页的第一章 **[引言]**，位于第96页的**附录C [代码规范]**，位于第102页的**附录E  [调试工具]**，位于第113页**附录F [开发工具]**。你至少应该大致看过从第58页**章节A.1 [Pintos系统的装载]**至第75页**章节A.5 [内存分配]**的内容，特别是第66页**章节A.3 [同步]**。此外，如果你想完成这次的课题，你也需要阅读第91页的**附录B [4.4BSD 时间调度]**。


##2.1 背景
###2.1.1 认识线程
第一步，阅读并理解线程系统的初始化代码。Pintos已配备了线程创建与线程完结调度，这是一个简单的线程切换调度器，而且Pintos还提供了优先级调度系统（信号量，进程锁，环境变量，优化屏障）。


在这些代码里，有些可能看起来略神秘。如果你还没有像引言中介绍的那样（请看位于第1页的第一章 **[引言]**）编译并运行基本系统，你应该立即进行这一步。你可以大致阅读源代码以了解在这一过程中发生了什么。一种比较不错的办法是在代码中任意位置加入`printf()`函数并重新编译以确定代码中各部分的作用及其作用顺序。你也可以在调试中运行系统内核并加入断点，逐步运行源代码并检查数据变化，等等。


进程及其所处的环境，在创建之后会受到调度。在此环境下你需要向`thread_creat()`中传递一个函数。当线程第一次被系统调度并运行时，它起始于此函数，并在此环境中运行。当函数返回信号时，线程终止。因此，在Pintos中的每一个线程都像一个个小程序，而与线程相对应的，被传递到`thread_creat()`的函数起到了普通程序中`main()`函数的作用。


在任意时间，仅有一个线程处于运行状态，其他线程（如果存在）将不会被激活。调度器决定了所有线程的运行顺序。（如果在接下来的时间点，没有线程会被运行，则特殊的“idle”线程将会被运行，`idle()`中提供了idle线程。）


环境切换的80x86架构机器码存在于**threads/switch.S**文件中。（在此我们不需要了解）。它所起到的作用是暂存现在正在运行的进程，并恢复到我们所要切换到的进程中。


使用GDB调试器，你可以仔细地查看在环境切换过程中发生了什么。（对此可以查看第105页的章节**E.5 [GDB]**。）你可以在`schedule()`中设置断点开始。
