#第二章 课题1.线程

在这一任务中，我们会向你提供一个最简单的、可以工作的线程系统。你的任务就是将其功能扩展，并在此过程中获得更多有关同步问题的知识。


你在这一任务中所要做的大部分工作都是在**threads**工作夹下完成的，另外还有一些工作需要你在**devices**目录下完成。需要强调的是编译需要在**threads**工作夹下完成。


在你阅读本任务的简述之前，以下的章节是你需要阅读的：位于第1页的第一章 **[引言]**，位于第96页的**附录C [代码规范]**，位于第102页的**附录E  [调试工具]**，位于第113页**附录F [开发工具]**。你至少应该大致看过从第58页**章节A.1 [Pintos系统的装载]**至第75页**章节A.5 [内存分配]**的内容，特别是第66页**章节A.3 [同步]**。此外，如果你想完成这次的课题，你也需要阅读第91页的**附录B [4.4BSD 时间调度]**。


##2.1 背景
###2.1.1 认识线程
第一步，阅读并理解线程系统的初始化代码。Pintos已配备了线程创建与线程完结调度，这是一个简单的线程切换调度器，而且Pintos还提供了优先级调度系统（信号量，进程锁，环境变量，优化屏障）。


在这些代码里，有些可能看起来略神秘。如果你还没有像引言中介绍的那样（请看位于第1页的第一章 **[引言]**）编译并运行基本系统，你应该立即进行这一步。你可以大致阅读源代码以了解在这一过程中发生了什么。一种比较不错的办法是在代码中任意位置加入`printf()`函数并重新编译以确定代码中各部分的作用及其作用顺序。你也可以在调试中运行系统内核并加入断点，逐步运行源代码并检查数据变化，等等。


进程及其所处的环境，在创建之后会受到调度。在此环境下你需要向`thread_creat()`中传递一个函数。当线程第一次被系统调度并运行时，它起始于此函数，并在此环境中运行。当函数返回信号时，线程终止。因此，在Pintos中的每一个线程都像一个个小程序，而与线程相对应的，被传递到`thread_creat()`的函数起到了普通程序中`main()`函数的作用。


在任意时间，仅有一个线程处于运行状态，其他线程（如果存在）将不会被激活。调度器决定了所有线程的运行顺序。（如果在接下来的时间点，没有线程会被运行，则特殊的“idle”线程将会被运行，`idle()`中提供了idle线程。）


环境切换的80x86架构机器码存在于**threads/switch.S**文件中。（在此我们不需要了解）。它所起到的作用是暂存现在正在运行的进程，并恢复到我们所要切换到的进程中。


使用GDB调试器，你可以仔细地查看在环境切换过程中发生了什么。（对此可以查看第105页的章节**E.5 [GDB]**。）你可以在`schedule()`中设置断点开始。


环境切换的80X86架构机器码存在于**threads/switch.S**文件中。（在此我们不需要了解）。它所起到的作用是暂存现在正在运行的进程，并恢复到我们所要切换到的进程中。


使用GDB调试器，你可以仔细地查看在环境切换过程中发生了什么。（对此可以查看第105页的章节**E.5 [GDB]**。）你可以在`schedule()`中设置断点开始，逐步运行之。务必关注每一个线程的地址与状态，以及其对应栈上的进程。你将注意到，每当一个线程调用`switch_threads()`函数时，`switch_threads()`便会返回另外一个线程。理解为何会调用`switch_threads()`与`switch_threads()`的返回值的区别，你便能理解线程系统。你可以查看第65页的章节**A.2.3 [线程切换]**来详细查看进程切换的有关内容。


不过，GDB可能会告诉你`schedule()`不存在，这是一个GDB的bug。你可以通过文件名与行号设置断点来解决这个问题。比如：`break thread.c:ln 行号`，此处行号是`schedule()`定义开始的行号。


**警告**：在Pintos系统中，每一个线程都被分配了一个不超过4kB大小的运行栈。内核可能会检测到栈溢出，但是不能进行完美检测。如果你在声明一个包含数据较多的数据结构，比如`int buf[100]`这样的非静态本地变量时，可能会出现诸如内核崩溃这样奇怪的问题。比栈分配更好的替换方法是页分配与块分配（详见第75页章节**A.5 [内存分配]**）。

----------

###2.1.2 源文件

本节是对`'threads'`文件夹及其下文件的简要预览，方便你能迅速找到你需要查看的代码。你不必修改其中的大多数文件。

`'loader.S'`


`'loader.h'`
：内核加载器。`'loader.h'`定义了被BIOS装入内存的512bytes的加载器的物理地址，加载器会搜索磁盘上的内核，将其加载入内存，并跳转到`'start.S'`的函数`start()`。详情见第58页的章节**A.1.1 [Pintos 加载]**。你应该不必查看这些代码，你也不应该修改他们。


`'start.S'`
：start.S完成了内存保护及80x86架构上32位基本操作的设置。与加载器不同的是，这部分代码是内核的一部分。详情见第59页的章节**A.1.2 [底层内核初始化]**。


`'kernel.lds.S'`
：用于链接内核的链接脚本。其作用是设置内存加载的物理地址，使`'start.S'`与内存映像加载同步开始。详情见第58页的章节**A.1.1 [Pintos 加载]**。你应该不必查看或者修改这些代码。


`'init.c'`


`'init.h'`
：内存初始化，包括内核主函数`main()`。你应该仔细查看`main()`函数，及其中系统的初始化代码。你也可以加入自己的代码。详情见第59页章节**A.1.3 [高层内核初始化]**。


`'thread.c'`


`'thread.h'`
：为系统提供基础的线程操作支持。你的大部分工作都将在这两个文件中完成。`'thread.h'`定义了线程结构，你可以在四个项目中对其进行修改。详情见第61页章节**A.2.1 [线程结构]**和章节**A.2 [线程]**的所有内容。


