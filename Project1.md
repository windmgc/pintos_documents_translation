#第二章 课题1.线程

在这一任务中，我们会向你提供一个最简单的、可以工作的线程系统。你的任务就是将其功能扩展，并在此过程中获得更多有关同步问题的知识。


你在这一任务中所要做的大部分工作都是在**threads**工作夹下完成的，另外还有一些工作需要你在**devices**目录下完成。需要强调的是编译需要在**threads**工作夹下完成。


在你阅读本任务的简述之前，以下的章节是你需要阅读的：位于第1页的第一章 **[引言]**，位于第96页的**附录C [代码规范]**，位于第102页的**附录E  [调试工具]**，位于第113页**附录F [开发工具]**。你至少应该大致看过从第58页**章节A.1 [Pintos系统的装载]**至第75页**章节A.5 [内存分配]**的内容，特别是第66页**章节A.3 [同步]**。此外，如果你想完成这次的课题，你也需要阅读第91页的**附录B [4.4BSD 时间调度]**。


##2.1 背景
###2.1.1 认识线程
第一步，阅读并理解线程系统的初始化代码。Pintos已配备了线程创建与线程完结调度，这是一个简单的线程切换调度器，而且Pintos还提供了优先级调度系统（信号量，进程锁，环境变量，优化屏障）。


在这些代码里，有些可能看起来略神秘。如果你还没有像引言中介绍的那样（请看位于第1页的第一章 **[引言]**）编译并运行基本系统，你应该立即进行这一步。你可以大致阅读源代码以了解在这一过程中发生了什么。一种比较不错的办法是在代码中任意位置加入`printf()`函数并重新编译以确定代码中各部分的作用及其作用顺序。你也可以在调试中运行系统内核并加入断点，逐步运行源代码并检查数据变化，等等。


进程及其所处的环境，在创建之后会受到调度。在此环境下你需要向`thread_creat()`中传递一个函数。当线程第一次被系统调度并运行时，它起始于此函数，并在此环境中运行。当函数返回信号时，线程终止。因此，在Pintos中的每一个线程都像一个个小程序，而与线程相对应的，被传递到`thread_creat()`的函数起到了普通程序中`main()`函数的作用。


在任意时间，仅有一个线程处于运行状态，其他线程（如果存在）将不会被激活。调度器决定了所有线程的运行顺序。（如果在接下来的时间点，没有线程会被运行，则特殊的“idle”线程将会被运行，`idle()`中提供了idle线程。）


环境切换的80x86架构机器码存在于**threads/switch.S**文件中。（在此我们不需要了解）。它所起到的作用是暂存现在正在运行的进程，并恢复到我们所要切换到的进程中。


使用GDB调试器，你可以仔细地查看在环境切换过程中发生了什么。（对此可以查看第105页的章节**E.5 [GDB]**。）你可以在`schedule()`中设置断点开始。


环境切换的80X86架构机器码存在于**threads/switch.S**文件中。（在此我们不需要了解）。它所起到的作用是暂存现在正在运行的进程，并恢复到我们所要切换到的进程中。


使用GDB调试器，你可以仔细地查看在环境切换过程中发生了什么。（对此可以查看第105页的章节**E.5 [GDB]**。）你可以在`schedule()`中设置断点开始，逐步运行之。务必关注每一个线程的地址与状态，以及其对应栈上的进程。你将注意到，每当一个线程调用`switch_threads()`函数时，`switch_threads()`便会返回另外一个线程。理解为何会调用`switch_threads()`与`switch_threads()`的返回值的区别，你便能理解线程系统。你可以查看第65页的章节**A.2.3 [线程切换]**来详细查看进程切换的有关内容。


不过，GDB可能会告诉你`schedule()`不存在，这是一个GDB的bug。你可以通过文件名与行号设置断点来解决这个问题。比如：`break thread.c:ln 行号`，此处行号是`schedule()`定义开始的行号。


**警告**：在Pintos系统中，每一个线程都被分配了一个不超过4kB大小的运行栈。内核可能会检测到栈溢出，但是不能进行完美检测。如果你在声明一个包含数据较多的数据结构，比如`int buf[100]`这样的非静态本地变量时，可能会出现诸如内核崩溃这样奇怪的问题。比栈分配更好的替换方法是页分配与块分配（详见第75页章节**A.5 [内存分配]**）。

----------

###2.1.2 源文件

本节是对`'threads'`文件夹及其下文件的简要预览，方便你能迅速找到你需要查看的代码。你不必修改其中的大多数文件。

`'loader.S'`


`'loader.h'`
：内核加载器。`'loader.h'`定义了被BIOS装入内存的512bytes的加载器的物理地址，加载器会搜索磁盘上的内核，将其加载入内存，并跳转到`'start.S'`的函数`start()`。详情见第58页的章节**A.1.1 [Pintos 加载]**。你应该不必查看这些代码，你也不应该修改他们。


`'start.S'`
：start.S完成了内存保护及80x86架构上32位基本操作的设置。与加载器不同的是，这部分代码是内核的一部分。详情见第59页的章节**A.1.2 [底层内核初始化]**。


`'kernel.lds.S'`
：用于链接内核的链接脚本。其作用是设置内存加载的物理地址，使`'start.S'`与内存映像加载同步开始。详情见第58页的章节**A.1.1 [Pintos 加载]**。你应该不必查看或者修改这些代码。


`'init.c'`


`'init.h'`
：内存初始化，包括内核主函数`main()`。你应该仔细查看`main()`函数，及其中系统的初始化代码。你也可以加入自己的代码。详情见第59页章节**A.1.3 [高层内核初始化]**。


`'thread.c'`


`'thread.h'`
：为系统提供基础的线程操作支持。你的大部分工作都将在这两个文件中完成。`'thread.h'`定义了线程结构，你可以在四个项目中对其进行修改。详情见第61页章节**A.2.1 [线程结构]**和章节**A.2 [线程]**的所有内容。

`'switch.S'`


`'switch.h'`
：切换进程的汇编代码，上文已有介绍。详情见章节**A.2.2 [线程函数]**。

`'palloc.c'`


`'palloc.h'`
：页分配器，将系统内存分配成大小为4kB的页。详情见章节**A.5.1 [页分配器]**。


`'malloc.c'`


`'malloc.h'`
：为系统内核所准备的`malloc()`与`free()`函数实例。详情见章节**A.5.2 [块分配器]**。


`'interrupt.c'`


`'interrupt.h'`
：基本中断开关与中断控制。详情见章节**A.4 [中断调控]**。


`'intr-stubs.S'`


`'intr-stubs.h'`
：底层中断控制的汇编代码。详情见章节**A.4.1 [中断控制基本架构]**。


`'synch.c'`


`'synch.h'`
：基本优先级调度：信号量，进程锁，环境变量，优化屏障。你将在四个项目中使用这些。详情见章节**A.3[同步调度]**。


`'io.h'`
：I/O函数。大多数在`devices`文件夹中的源代码需要这个文件。


`'vaddr.h'`


`'pte.h'`
：配置虚拟地址与页索引的函数与宏。这将在项目3中非常重要。但现在你可以忽略他们。


`'flags.h'`
：作用于80x86`flags`寄存器的宏定义。详情见章节**3.4.3 [IA32-v1]、[EFLAGS寄存器]**。


####2.1.2.1 `devices`文件


基本线程系统也包括在`devices`文件夹中的以下文件：


`'timer.c'`

`'timer.h'`
：系统计时器，默认计100次为1秒。你会在本项目中修改这个代码。


`'vga.c'`


`'vga.h'`
：VGA显示驱动。与屏幕输入的功能有关。你应该不需要查看这些代码。而且`printf()`函数会调用这些代码，因此你也不需要单独调用它。


`'serial.c'`


`'serial.h'`
：串口驱动。`printf()`会调用它，因此你也不需要自己做。


`'block.c'`


`'block.h'`
：快设备的抽象层定义，例如随机存取，以数组形式管理的快设备。Pintos支持两种块设备：IDE磁盘与分区。块设备在第二项项目之前不会用到。


`'ide.c'`


`'ide.h'`
：功能支持最多4块IDE磁盘的扇区存取。


`'partition.c'`


`'partition.h'`
：查看这些代码，你可以理解磁盘分区的功能，如何让单一的一块磁盘通过分区来分别用于不同的用处。


`'kbd.c'`


`'kbd.h'`
：键盘驱动。将按键行为传递到输入层。


`'input.c'`


`'input.h'`
：输入层。含有处理键盘输入或串口输入的队列。


`'intq.c'`


`'intq.h'`
：中断队列，管理内核线程与中断调控的循环队列。被键盘与串口设备所使用。


`'rtc.c'`


`'rtc.h'`
：实际的时钟驱动。使内核可以控制当前的日期与时间。通常上，这会被`thread/init.c`文件使用以生成用于随机数字生成器的种子数。


`'speaker.c'`


`'speaker.h'`
：用于在扬声器上产生声音的驱动。


`'pit.c'`


`'pit.h'`
：设置8254可编程中断计时器的代码。会被`devices/timer.c`以及`devices/speaker.c`所使用。


####2.1.2.2 `lib`文件

最后，本节要介绍的`lib`与`lib/kernel`包含这许多有用的库文件。（`lib/user`会被用于项目2的用户编程，但它不属于内核的一部分。）以下是细节：


`'ctype.h'`

`'inttypes.h'`

`limits.h`

`stdarg.h`

`stdbool.h`

`stddef.h`

`stdint.h`

`stdio.c`

`stdio.h`

`stdlib.c`

`stdlib.h`

`string.c`

`string.h`
：标准C库文件。详情见章节**C.2 [C99]**。为了安全起见，有一些不安全的函数被本节隐藏了起来，你可以在章节**C.3 [不安全的字符串函数]**中见到他们。


`'debug.c'`


`'debug.h'`
：Debug所使用的函数与宏。详情见附录**E [Debug工具]**.


`'random.c'`


`'random.h'`
：伪随机数生成器。你可以通过以下三个方法实现随机数的生成。在每一次运行的`-rs`参数上制定新的种子数；使用Bochs之外的虚拟器；或者对pintos指定`-r`参数。


`'round.h'`
：Rounding宏定义。


`'syscall-nr.h'`
：系统呼叫数。不会在项目2之前使用。


`'kernel/list.c'`


`'kernel/list.h'`
：双链表结构体。在Pintos系统代码中使用广泛。你也会在项目1中使用。


`'kernel/bitmap.c'`


`'kernel/bitmap.h'`
：位图功能支持。你可以使用，不过你应该不会在项目1中用到。


`'kernel/hash.c'`


`'kernel/hash.h'`
：哈希表功能支持。会在项目3中用到。

`'kernel/console.c'`

`'kernel/console.h'`

`'kernel/stdio.h'`
：`printf()`及其他几个函数的功能支持。



----------

###2.1.3 同步调度

